diff --git a/lang/syn/src/parser/accounts/constraints.rs b/lang/syn/src/parser/accounts/constraints.rs
index 39617ea4..992da2bd 100644
--- a/lang/syn/src/parser/accounts/constraints.rs
+++ b/lang/syn/src/parser/accounts/constraints.rs
@@ -1,6 +1,7 @@
 use crate::*;
 use syn::parse::{Error as ParseError, Result as ParseResult};
-use syn::{bracketed, Token};
+use syn::{braced, bracketed, Expr, Token};
+use syn::{parenthesized, token};
 
 pub fn parse(f: &syn::Field, f_ty: Option<&Ty>) -> ParseResult<ConstraintGroup> {
     let mut constraints = ConstraintGroupBuilder::new(f_ty);
@@ -359,17 +360,143 @@ pub fn parse_token(stream: ParseStream) -> ParseResult<ConstraintToken> {
                     _ => return Err(ParseError::new(ident.span(), "Invalid attribute")),
                 }
             } else {
+                // stream.parse::<Token![=]>()?;
+                // let span = ident
+                //     .span()
+                //     .join(stream.span())
+                //     .unwrap_or_else(|| ident.span());
+                // let seeds;
+                // let bracket = bracketed!(seeds in stream);
+                // ConstraintToken::Seeds(Context::new(
+                //     span.join(bracket.span).unwrap_or(span),
+                //     ConstraintSeeds {
+                //         seeds: seeds.parse_terminated(Expr::parse)?,
+                //     },
+                // ))
+
+                // // ---- NEW CODE First version ----
+                //  stream.parse::<Token![=]>()?;
+                // let span = ident
+                //     .span()
+                //     .join(stream.span())
+                //     .unwrap_or_else(|| ident.span());
+                // let seeds;
+                // let bracket = bracketed!(seeds in stream);
+                // ConstraintToken::Seeds(Context::new(
+                //     span.join(bracket.span).unwrap_or(span),
+                //     ConstraintSeeds {
+                //         seeds: {
+                //             let parsed_seeds = seeds.parse_terminated(Expr::parse)?;
+                //             for expr in &parsed_seeds {
+                //                 println!("Parsed seed: {:?}", expr); // <--- ADD THIS
+                //             }
+                //             parsed_seeds
+                //         },
+                //     },
+                // ))
+
+                // // ---- NEW CODE Second version ----
+
+                // // FOr List checking : ` List(Punctuated<Expr, Token![,]>)` "I want to parse multiple Rust expressions, separated by commas."
+                // stream.parse::<Token![=]>()?;
+                // let span = ident
+                //     .span()
+                //     .join(stream.span())
+                //     .unwrap_or_else(|| ident.span());
+
+                // let lookahead = stream.lookahead1();
+                // if lookahead.peek(token::Bracket) {
+                //     let seeds;
+                //     let bracket = bracketed!(seeds in stream);
+                //     ConstraintToken::Seeds(Context::new(
+                //         span.join(bracket.span).unwrap_or(span),
+                //         ConstraintSeeds::seeds(seeds.parse_terminated(Expr::parse)?),
+                //     ))
+                // } else {
+                //     let expr: Expr = stream.parse()?;
+                //     ConstraintToken::Seeds(Context::new(span, ConstraintSeeds::Expr(expr)))
+                // }
+
+                // // ---- NEW CODE Third version ----
+                // stream.parse::<Token![=]>()?;
+                // let span = ident
+                //     .span()
+                //     .join(stream.span())
+                //     .unwrap_or_else(|| ident.span()); //span is identity of location of the token
+
+                // let lookahead = stream.lookahead1();
+                // // If it's [a, b], then use bracketed + parse_terminated
+                // if lookahead.peek(token::Bracket) {
+                //     let seeds;
+                //     let bracket = bracketed!(seeds in stream); //Tokens inside [...]
+
+                //     ConstraintToken::Seeds(Context::new(
+                //         span.join(bracket.span).unwrap_or(span),
+                //         ConstraintSeeds {
+                //             seeds: (seeds.parse_terminated(Expr::parse)?),
+                //         },
+                //     ))
+                // } else {
+                //     //Else it must be a single expression like my_func(...)
+
+                //     let expr: Expr = stream.parse()?;
+                //     let mut seed_list = Punctuated::new(); //it create empty list of expr ,[]
+                //     seed_list.push(expr);
+
+                //     ConstraintToken::Seeds(Context::new(span, ConstraintSeeds { seeds: seed_list }))
+                // }
+
+                // Todo:Add support any type of brackets
+                //     stream.parse::<Token![=]>()?;
+                //     let span = ident
+                //         .span()
+                //         .join(stream.span())
+                //         .unwrap_or_else(|| ident.span());
+
+                //     let seeds;
+                //     let bracket = parenthesized!(seeds in stream);
+
+                //     ConstraintToken::Seeds(Context::new(
+                //         span.join(bracket.span).unwrap_or(span),
+                //         ConstraintSeeds {
+                //             seeds: seeds.parse_terminated(Expr::parse)?,
+                //         },
+                //     ))
+                // }
+
+                // Support three types of brackets [],{} and ()
                 stream.parse::<Token![=]>()?;
                 let span = ident
                     .span()
                     .join(stream.span())
                     .unwrap_or_else(|| ident.span());
-                let seeds;
-                let bracket = bracketed!(seeds in stream);
+
+                // Helper to extract `content` and `delim_span` for any bracket type
+                let (seeds_content, delim_span) = if stream.peek(token::Bracket) {
+                    let content;
+                    let bracket = bracketed!(content in stream);
+                    (content, bracket.span)
+                } else if stream.peek(token::Paren) {
+                    let content;
+                    let paren = parenthesized!(content in stream);
+                    (content, paren.span)
+                } else if stream.peek(token::Brace) {
+                    let content;
+                    let brace = braced!(content in stream);
+                    (content, brace.span)
+                } else {
+                    return Err(ParseError::new(
+                        stream.span(),
+                        "expected one of: `[...]`, `(...)`, or `{...}` after `seeds =`",
+                    ));
+                };
+
+                // Leverage a helper function for seeds constraint building (recommended for DRYness)
+                let combined_span = span.join(delim_span).unwrap_or(span);
                 ConstraintToken::Seeds(Context::new(
-                    span.join(bracket.span).unwrap_or(span),
+                    combined_span,
                     ConstraintSeeds {
-                        seeds: seeds.parse_terminated(Expr::parse)?,
+                        seeds: seeds_content.parse_terminated(Expr::parse)?,
                     },
                 ))
             }
